#### *list
```py
#-R에서 벡터처럼 여러 개의 값을 하나로 묶기 위한 최소 단위 자료구조
#-1차원 형식
#- 중첩구조 가능(리스트 안에 리스트 삽입이 가능)
#-서로 다른 데이터 타입 입력 가능

#1. 생성
L1=[1,2,3]
L2=[1,'2',3];L2
L3=[1,2,[3,4]];L3
L4=[1,2,3,4,5,6]

#2. 색인
L1[0]     #정수(position)색인 가능
L1[0:2]   #슬라이스(연속범위) 색인 가능
L1[[0:2]] #리스트를 전닿한 색인 불가(동시에 여러 개 전달 불가)
L1[1:]    #1~끝 색인
L1[:2]    #처음~1 색인
L3[2][0]
L1[-1]    #reverse indexing
L4[::2]   #start : end : by


#3. 수정 
L1[0]=10;L1
L1[1]=[20,30];L1   # 여러 개 들어감
L1[1:3]=[20,30];L1 # 각각 들어감

#4. 확장
c(v1,4) #(=>r에서 풀리면서 묶였음)
L1.append(40);L1
L1[4]=50          #새로운 위치에 값 할당 불가(out of range)

#5. 확장
l1=[1,2,3]
l2=[4,5,6]

l1+l2     #리스트이 확장
l1+[4]    #리스트에 원소 추가
l1*3      #3번 반복 확장

l1.extend([5])  #리스트에 원소 추가

#6. 삭제 
del(l1[3]);l1   #원소의 삭제
del(l1[0]);l1   #중간 위치 원소 삭제 가능
#R에서는 각 위치가 기억되고 있어서 NULL값으로 만들 수 없었지만 여기선 된다
del(l1);l1      #객체 자체 삭제
l2=[];l2        #객체 원소 삭제

#2차원 형식 리스트
L1=[[1,2,3],[4,5,6],[7,8,9]]
len(L1)  #3, 리스트 원소 개수

L1[1][0] #4

#[연습문제] 
#계산기 프로그램
money=int(input('지폐로 교환할 돈은? :'))

q50=money//50000
money=money%50000

q10=money//10000
money=money%10000

q5=money//5000
money=money%5000

q1=money//1000
money=money%1000

print('50000원짜리==> %d장' % q50)
print('50000원짜리==> %d장' % q10)
print('50000원짜리==> %d장' % q5)
print('50000원짜리==> %d장' % q1)
print('지폐로 바꾸지 못한 돈==> %d원' % money)
```
------------
------------
#### *논리연산자
```py
v1=10
(v1>5) & (v1<15)
(v1>5) and (v1<15)

(v1>5) | (v1<15)
(v1>5) or (v1<15)

!(v1>5)     #R에서의 부정 연산자
not(v1>5)   #파이썬 부정 연산자
```
---------
-------------
#### * lambda
```py
#-사용자 정의 함수(축약형)
#-output으로는 즉시 얻을 수 있는 문법만을 사용 가능
#-복잡한 프로그래밍 처리 불가(조건문,반복문)

# 1)기존 함수 선언 방식
def 함수명:
    
# 2)lambda
lambda input : output

#예제) 입력된 값의 10% 증가값을 리턴하는 함수 생성
f1=lambda x:x*1.1  
f1(10)

#예제) 두 수를 전달받아 두 수의 합을 리턴
f2=lambda x,y=0 : x+y    #인자의 기본값 선언 가능
f2=lambda x=0,y : x+y    #default값이 선언된 인자 뒤에도 default값을 설정요구
f2(1,10)
f2(1)
  
##리스트의 벡터연산(적용함수)
L1+1      #각 원소에 반복적용 불가

#예제) L1의 각 원소에 10%인상된 값 연산
f1(L1)            #불가
list(map(f1,L1))  #가능(map함수에 의한 반복적용)

#예제) l1+l11의 결과 리턴
L11=[1,2,3,4]

L1+L11               #불가, 리스트의 확장
list(map(f2,L1,L11)) #가능

#[참고]
#map처리는 연산결과를 메모리에 할당함, 출력 명령이 따로 필요함
#출력시, list로 묶어줘야 함

#[연습문제]
#다음의 리스트를 생성
l1=[1,2,3,4]
l2=[10,20,30,40]
l3=[100,200,300]
l4=['서울','부산','대전','전주']
l5=['abc@naver.com','a123@hanmail.net']

#1. l2의 l1승 출력, 10^1, 20^2...
f1=lambda x,y : x**y
list(map(f1,l2,l1))

#2. l4의 값에 '시'를 붙여 출력
f2=lambda x : x+'시'
list(map(f2,l4))

#3. l5에서 이메일 아이디만 출력
f3=lambda x : x.split('@')[0]
list(map(f3,l5))
```